#ifndef _CTEXTURE_H_A01B0DE1_0709_4939_92ED_4D272F4CA16E__
#define _CTEXTURE_H_A01B0DE1_0709_4939_92ED_4D272F4CA16E__

/*
*************************************************************************
模块名  : CTexture
文件名  : CTexture.h
实现功能:
作者    : 周健
版本    :
-------------------------------------------------------------------------
备注    : 画一个三角体和正方体，代码为NEHE的。
-------------------------------------------------------------------------
修改记录: 纹理映射
创建时间：2015.11.30  21:58
*************************************************************************
* 版本所有(c)    保留所有权利                                           *
************************************************************************/

#include "GLFrame.h"												/**< 包含基本的框架类 */
#include "CBMPLoader.h"

/** 从GL_Application派生出一个子类 */
class CTexture : GLApplication
{
public:
	bool	Init();										/**< 执行所有的初始化工作，如果成功函数返回true */
	void	Uninit();										/**< 执行所有的卸载工作 */
	void	Update(DWORD milliseconds);							/**< 执行所有的更新操作，传入的参数为两次操作经过的时间，以毫秒为单位 */
	void	Draw();												/**< 执行所有的绘制操作 */

private:
	friend class GLApplication;								/**< 父类为它的一个友元类，可以用来创建程序的实例，见函数GL_Application * GL_Application::Create(const char * class_name) */
	CTexture(const char * class_name);						/**< 构造函数 */
	/** 用户自定义的程序变量 */
	float	m_Angle;											/**< 使用它来旋转三角形 */
	CBMPLoader  Texture;									/**< 位图载入类的对象 */
};


#endif	// ___CTEXTURE_H__

/*
纹理映射的过程
将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。包括：
1.纹理定义 纹理定义在一个数组中，该数组表示纹理空间中一组网格点上的纹理值，网格点之间的其他点的纹理值可以通过插值。通过纹理空间与
           物体空间之间的坐标转换，就可以把纹理映射到物体表面了。
2.纹理控制 纹理图像的纹理怎样对应到屏幕上的像素，实现纹理缩放和纹理重复。
	2.1 滤波 纹理一般为矩形，但当他被映射到一个多边形或曲面上并变换到屏幕坐标时，纹理的单个纹素和屏幕上的像素不太可能一一对应。
	    屏幕上单个像素可以对应一个纹素的一小部分(放大)/一大批纹素(缩小)
3.纹理映射方式
4.纹理坐标 绘制纹理映射场景时，要给每个顶点定义几何坐标，也要定义纹理坐标。几何坐标决定顶点在屏幕上绘制位置，纹理坐标决定纹理图像中
           哪一个纹素赋予该顶点，并且顶点之间的纹理坐标也需要通过插值
	
纹理对象  用于存储纹理数据，可以大大提高性能。就可以不用上面底层方式了。
1.生成纹理对象名称  使用任何非0的无符号证书作为纹理对象名，避免重用纹理对象名，用glGenTextures()
2.创建纹理对象，绑定到纹理数据   glBindTexture  绑定纹理对象名，创建纹理对象
3.再次绑定，将其中的纹理映射到物体上
4.删除纹理对象。
*/